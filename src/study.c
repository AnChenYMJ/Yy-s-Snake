


void study()
{
	//贪吃蛇项目介绍
	if (1)
	{
		/*
			总的代码量加上括号等，才500行左右
			锻炼C语言的基础知识，用到了数据结构中的双向链表
			功能：
				暂停、启动
				tab键切换难度（速度）
				esc键退出游戏
				将游戏得分存入一个文件中
		*/
	}
	//打印提示信息（就是操作提示之类的）
	if (2)
	{
		/*
			用printf，\t \n 之类的来打印相关信息
			也可以像此前俄罗斯方块的 用Gotoxy,指定光标位置来打印
			\t在windows下占8个空格，linux下4个空格，根据编译器与环境不同而有所不同

			补充：
				C语言中，Head(void); 函数参数不适用的话要加上void，表示不接收参数
				C语言标准下不加void的话，会看做此函数参数不明确，调用函数时加再多参数都不报错：如 Head（1，2，5，9）;
				C++标准下可以不加void，这点与C语言不同，不加也能识别到
		*/
	}
	//印游戏区域（游戏的边框、边界）
	if (3)
	{
		/*
			与俄罗斯方块的 数组背景处理方式是一样的
			在游戏区域，用一个二维数组对应一块区域，当某位置的数组元素为1时，那位置则是实心

			打印一个框只需要知道 长宽即可 就能用4个条件 一次性打印出框来
		*/
	}
	//设置光标位置 GotoXY函数
	if (4)
	{
		/*
			与俄罗斯方块的GotoXY一样，指定光标位置
			要自己写函数，还需要绑定我们要操控的窗口，（用句柄绑定）那个函数需要<windows.h>

			注意：行对应的是Y 列对应的是X 别搞错了，画个直角坐标系就很清楚了
			GotoXY(0,0)此函数从下标0 0 开始的，参数填的也是坐标。所以比如 GotoXY(5,6) 其实是第6行 第7列
			此函数的参数是short类型，因为下面的函数只支持short类型
		*/
	}
	//定义蛇身体结构体
	if (5)
	{
		/*
			俩结构体
			1.一个记录当前节点坐标，和移动的方向
			2.一个则是双向链表中的节点，记录上一节点、下一节点的地址。

			写命名时的规范，如下：指针的名字前加p int类型命名前加i  st则代表结构体 em则是枚举

			enum枚举默认从0开始 0 1 2 3 ... 
			使用枚举时 enum Dir emdir; 是最规范的 虽然可以写成int Dir emdir;
		
		*/
	}
	//游戏开始时，小蛇的刷新点，及长度恒定为3节点，画出小蛇
	if (6)
	{
		/*
			pT->stSnake.iX = rand() % (X - 2) + 1;			//这俩是该节点游戏开始生成的坐标，用随机数来决定
			pT->stSnake.iY = rand() % (Y - iCount - 1) + 1;	//这俩的边界条件，看笔记，我用了东方向，所以左侧可能会突破边界，-在外+2即可，让范围在3~19之间，这样从东向西生成时，不会有越界

			我们设定的X Y 都是20 在一个20*20的方框中，去掉实心的部分为（X-2）== 18，取余后范围是0~17，而我们想要的是1~18 故（X-2）+1
			iY就是行，一个3节点的小蛇在游戏开始随机出现的时候，不加限制的话，可能小蛇脑袋在20*20的框里，但身体超出去了
				所以用（Y - iCount）== 17 再减去实心方块（Y - iCount - 2） 再让随机数范围从1开始（Y - iCount - 1）+1
				其实可以减得更多，如（Y - iCount - 8）就把小蛇生成的范围压缩了


			画蛇：
			与释放链表的部分很类似，先参数合法性检测，再记录头节点
			用头节点遍历，遍历到的当前节点的成员stSnake.iX  stSnake.iY 用他俩思索Gotoxy到框内对应坐标位置 因为iY是列，而一个符号占两格列，所以使用时要*2
			注意要考虑到小蛇朝向，然后推理是否边界时会越界，比如我的朝东，那么如果头节点生成在最左侧，那剩下以它为参考的剩余节点就会打印出来越界了
		*/
	}
	//释放蛇链表
	if (7)
	{
		/*
			采用了malloc，所以必须要释放，否则内存泄漏
			释放的逻辑很简单，记住背下来就可以，不要每次都去思索
			1.写释放函数，参数合法性检测
			2.pT记录头节点（不要直接用头节点）
			3.循环中pp记录当前节点地址，pT转向下一个节点
			4.释放pp，然后循环往复，直到NULL == pT，没有节点
			5.最后要给头尾节点赋空

			释放链表，在程序结束，或者游戏结束时释放
		*/
	}
	//小蛇的移动
	if (8)
	{
		/*
			此前已经用随机数，随机生成了小蛇的生成位置
			小蛇还需要移动起来。
			移动方式：
				小蛇是一个链表，从尾节点依次向头节点移动即可实现移动
				即倒数2的节点坐标赋值给尾节点，倒数3的坐标赋值给倒数2的节点
				最后头节点向某个方向移动就好了，实现了移动，且后节点会跟随前节点的脚步

				大体分为两部分：非头节点、头节点
				非头节点：从末尾节点一个个的向前移动
				头节点特殊处理：头节点来决定向哪个方向移动

			消除尾部残留
				原来移动后，尾部的打印因为没有刻意消除，会留在原地，导致长长的拖尾
				解决方法：坐标移动到尾节点位置打印“  ”消除痕迹，且必须在小蛇移动前消除，因为移动后尾节点坐标变化，导致原本位置的残留还在
		*/
	}
	//按键扫描
	if (9)
	{
		/*
			讲到了同步异步，阻塞的概念，在TCP中也已经学过了
			一些函数能检测按键： scanf()  getchar()  gets()  getch()  getc() 他们的共同点：都是阻塞的，执行一个时会把程序卡住，直到有所操作程序才继续
			简单来说，就是按一次动一次，不按就卡在那，程序无法继续执行

			解决方法：按键异步处理
			按键异步处理的2种方式：
				一：开一根线程，将上述的阻塞的函数放到线程中去，这样的话与主程序的线程就不冲突了，只是共享数据
				二：用GetAsyncKeyState 函数，本编译器提供的，MSDN上能看到调用对应按键的宏加上此函数就能检测了

			GetAsyncKeyState检测按键：每个按键会有不同的状态，此函数都能检测出来，如：双击，按下，抬起，按住
				也可以不用宏来表示按键，用按键独有的16进制数也可以，注意，字母按键 如'A'才是有效的，单引号加大写，小写的话无法识别
		*/
	}
	//产生食物，与小蛇吃食物
	if (10)
	{
		/*
		产生食物：
			用随机数产生食物坐标（必须在游戏区域内，不会覆盖边界，让其坐标在1~19之间）
			判断坐标是否与蛇身节点重合，有重合就重新生成食物
			没有重合就画出该食物，且该食物坐标位置的背景数组赋值一个特殊值，比如2 ，方便后面小蛇吃食的时候操作

		小蛇吃食物长大：
			本质上是链表的尾添加：创建节点--节点成员赋值--添加到链表尾部
			画出蛇身节点时，要考虑到吃之前的尾巴移动方向，然后在尾巴后根据移动方向来添加（画出）节点
			所以 节点成员赋值 中的新节点坐标，要根据蛇身原尾节点的方向来判定再赋值，用了一个switch

		吃食物：
			头节点坐标与食物坐标重合，就相当于吃到了，让蛇身长大，返回true

		问题：之前按键检测时，有设定为在该方向移动时按下方向键，就调用一次：清除痕迹、移动、画新形状 相当于加速
			结果是，加速过程中，不能吃到食物
		解决方案：
			每个按键加速的else if 下，加入食物判断即可

		我的疑惑：
			本次案例大量用到了 坐标  也就意味着，游戏区域的坐标与背景数组的对应关系是唯一恒定的
			不能瞎改，每次使用到相关坐标，千万注意要与其它坐标保持统一标准，不能随便更改坐标标准
			否则坐标与坐标之间标准不同，那相同数字的坐标对应的点是不一样的。

		我的思路：
			Frame函数中 背景数组从0 0 到19 19   0 == i || 0 == j || (X - 1) == i || (Y - 1) == j 这是边框的坐标
			那除边框外，坐标是1 1 到 18 18
			CreateSnake函数中给节点赋值坐标时，如rand() % (X - 2) + 1; 则是从1 1 到 18 18
			如：rand() % (Y - iCount - 1) + 1 + 2 如果iCount为3 则是从 3 3 到 18 18  从3开始是为了避免向左生成的节点越界
			生成食物的Food函数中：int x = rand() % (X - 2) + 1  则是让食物坐标在1 1 到 18 18 范围内
			所以综上所述，它们的坐标始终是遵循统一标准的，始终在一个框内，框恒定不变，那框内相对坐标也就恒定不变
			用框内的恒定不变的相对坐标，来当作二维数组下标，那么数组对应下标的元素也就唯一对应框内的对应坐标
			就不会乱啦，终于搞清楚了

		*/
	}
	//撞边死亡
	if (11)
	{
		/*
			让头节点的坐标去判断，是否该以该坐标为数组下标时，对应数组元素为1，如果是，则撞到边界游戏结束
			
			也可以自行添加其它游戏结束的条件，比如自己撞自己（我用的也是坐标判断）等

		*/
	}
	//其他功能
	if (12)
	{
		/*
			实时打印长度，	（头节点负责计数，用头节点的iCOunt）
			重新游戏			（清屏，释放原链表，画面等等进行初始化即可）
			esc退出游戏		（用一个全局变量来标识esc键是否按下，根据标识是否要退出循环）
			暂停与启动		（用一个全局变量来标识暂停与启动，让该标识控制蛇的移动等等（if），也可以控制按键检测（if））
			切换游戏难度		（用一个全局变量来控制Sleep即可，用一个静态变量自加 求余% 控制在0~3，就分成了4个等级，switch每等级能改变速度，且打印难度提示）
			保存数据到文件	（创建存储数据的结构体，时间、长度。然后打开文件，写入文件，关闭文件即可（详情看代码）注意用的是"a" 接着写，且存入文件的格式不一定与记事本相同，可以用fread函数读取）
			读取数据文件		（打开文件，创建接收数据的结构体，读取文件，注意要想直观的看时间格式，需要用ctime_s来转格式，注意参数）
		*/
	}
	//BUG与修正
	if (13)
	{
		/*
			有个问题，就是存储数据时，我们正常死亡了，再按Esc退出，同样的一局分数就保存了2次
			可进行修改，比如定义一个全局变量，记录此局游戏，一种方式保存了数据后，变量变化，其它方式就不能保存了

			遇到的问题 ：fopen_s打开一个文件一定要用fclose，否则下次fopen_s打开文件就会返回13错误码
						此前一直不能保存，我以为是逻辑漏洞，结果是Read函数的fopen_s 打开文件后没有fclose关闭，导致Save的fopen_s 没有权限打开，调试得到13错误码
						所以fopen_s 与 fclose 一定要配套出现
		*/
	}
}